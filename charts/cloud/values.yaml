nodeSelector: &nodeSelector {}
podAnnotations:
  app: protopie

image:
  cloud:
    api:
      pullPolicy: IfNotPresent
      repository: protopie/enterprise-onpremises
      tag: api-15.8.1
    web:
      pullPolicy: IfNotPresent
      repository: protopie/enterprise-onpremises
      tag: web-15.8.1
    userTesting:
      pullPolicy: IfNotPresent
      repository: 310455165573.dkr.ecr.ap-northeast-2.amazonaws.com/enterprise-cloud
      tag: user-testing-15.8.0
    userTestingServer:
      pullPolicy: IfNotPresent
      repository: 310455165573.dkr.ecr.ap-northeast-2.amazonaws.com/enterprise-cloud
      tag: ut-dev
    userTestingDb:
      pullPolicy: IfNotPresent
      repository: 310455165573.dkr.ecr.us-west-2.amazonaws.com/postgresql
      tag: 16.6.0
    userTestingRedis:
      pullPolicy: IfNotPresent
      repository: 310455165573.dkr.ecr.us-west-2.amazonaws.com/redis
      tag: 8.2-alpine
  nginx:
    pullPolicy: IfNotPresent
    repository: nginx
    tag: 1.26.3-alpine
  db:
    pullPolicy: IfNotPresent
    repository: bitnami/postgresql
    tag: 14.15.0
  analytics:
    web:
      pullPolicy: IfNotPresent
      repository: 310455165573.dkr.ecr.ap-northeast-2.amazonaws.com/analytics-enterprise
      tag: web-1.0.1
    api:
      pullPolicy: IfNotPresent
      repository: 310455165573.dkr.ecr.ap-northeast-2.amazonaws.com/analytics-enterprise
      tag: api-1.0.1

ingress:
  # If you want to use a specific ingress class, set the value here.
  ingressClassName: ""
  enabled: false
  host: ""
  annotations: {}
  # To enable certificate, set the value to true.
  tls:
    enabled: false

# eg) for private docker image registry (imagePullSecrets)
# imageCredentials:
#   registry: <repo>
#   username: <username>
#   password: <pw>
#   email: <email>
# OR
# imagePullSecrets:
#   - name: <protopie-private-registry>

imageCredentials: null
imagePullSecrets: null

userTesting:
  enabled: false # Set to true to enable User Testing Server deployment

  # Migration flag for backward compatibility
  # true:  Deploy legacy ent-cloud-ut (Kotlin/KTOR, ports 4444/4445, no db/redis)
  # false: Deploy new user-testing-server (NestJS, port 3030, requires PostgreSQL + Redis)
  #
  # Migration path:
  # 1. Keep useLegacy: true for existing deployments (no changes)
  # 2. Test new stack in separate environment with useLegacy: false
  # 3. Switch production environments one by one
  # 4. Remove legacy deployment after full migration
  useLegacy: true

  replicas: 1
  logLevel: "info"
  cloudApiBaseUrl: "http://ent-cloud-api-svc"
  useMockCloudApi: "false"
  jwtExpiresIn: "1d"

  # User Testing Server resources
  resources:
    requests:
      cpu: "250m"
      memory: "512Mi"
    limits:
      cpu: "1000m"
      memory: "2Gi"

  # PostgreSQL Database configuration
  db:
    user: "user_testing"
    database: "user_testing"
    password: "local-dev-password-change-in-prod" # REQUIRED: Set in per-environment values (e.g., values-f1.yaml)
    postgresPassword: "local-dev-postgres-password-change-in-prod" # REQUIRED: Set in per-environment values
    storage: "10Gi"
    storageClassName: ""
    # Change this value to force fresh EFS storage (e.g., "v1" â†’ "v2")
    # Useful for recovering from corruption without deleting EFS data
    storageVersion: "v1"

    resources:
      requests:
        cpu: "500m"
        memory: "4Gi" # Increased for large JSONB payload support
      limits:
        cpu: "2000m"
        memory: "8Gi" # Minimum for shared_buffers=4GB + work_mem overhead
        # For production with high load, consider 16Gi

    # PostgreSQL Configuration for Large JSONB Payloads (>255MB)
    # Related: ADR-025, ADR-018, ADR-019
    # These values configure PostgreSQL to handle theoretical maximum
    # ProtoPie recordings while maintaining optimal performance for
    # typical 1-10MB workloads. Current HTTP limits remain at 20MB/10MB.
    config:
      # Write-Ahead Log Configuration
      maxWalSize: "4GB" # Default: 1GB
      minWalSize: "1GB" # Default: 80MB
      checkpointCompletionTarget: "0.9" # Default: 0.5

      # Memory Configuration
      sharedBuffers: "4GB" # 25% of 16GB (adjust for pod memory)
      workMem: "256MB" # Default: 4MB (per-operation!)
      maintenanceWorkMem: "1GB" # Default: 64MB
      effectiveCacheSize: "12GB" # 75% of 16GB (query planner hint)

      # Connection Limits
      maxConnections: "100" # Default: 100
      tempFileLimit: "5GB" # Default: -1 (unlimited)

      # Timeouts
      statementTimeout: "120000" # 120s = 2 minutes

      # Performance
      maxParallelWorkers: "4" # Default: 2

      # Logging (for monitoring)
      logMinDuration: "5000" # Log queries >5s
      logAutovacuumMinDuration: "1000" # Log VACUUM >1s
      logCheckpoints: "on" # Log checkpoint activity
      logTempFiles: "102400" # Log temp files >100MB

      # TOAST Compression (optional - may not be supported by all builds)
      # IMPORTANT: Bitnami PostgreSQL images may not support this parameter
      # Leave commented out. For better compression, use per-table ALTER:
      # ALTER TABLE scenarios ALTER COLUMN recording_data SET COMPRESSION lz4;
      # toastCompression: "lz4"

  # Redis Cache configuration
  redis:
    resources:
      requests:
        cpu: "100m"
        memory: "256Mi"
      limits:
        cpu: "500m"
        memory: "512Mi"

  # JWT Secret for authentication
  jwtSecret: "" # REQUIRED: Set in per-environment values (openssl rand -base64 32)

  # Cloud-API Service Key for server-to-server authentication
  cloudApiServiceKey: "" # REQUIRED: Set in per-environment values (obtain from cloud-api team)

analytics:
  enabled: false
  web:
    env:
      DEBUG: DO_NOT_DEFINE_THIS_VARIABLE_ON_PRODUCT
      COOKIE_NAME: AE_TOKEN
      URL_BASE_PATHNAME: "/analytics/"
      AE_API_USER_ID: "admin"
      # If left empty, a random password will be generated automatically
      AE_API_USER_PASS: ""
  api:
    env:
      ROOT_PATH: "/api/analytics/"
      DEBUG: DO_NOT_DEFINE_THIS_VARIABLE_ON_PRODUCT
      ALLOWED_HOSTS: "*"
      # If left empty, a random password will be generated automatically
      DJANGO_SECRET_KEY: ""

cloud:
  host: ""
  share:
    enabled: false
    host: ""
  api:
    replicas: 1
    startupProbe:
      httpGet:
        path: /
        port: http
      initialDelaySeconds: 0
      successThreshold: 1
      periodSeconds: 10
      failureThreshold: 3
      timeoutSeconds: 1
    livenessProbe:
      httpGet:
        path: /
        port: http
    readinessProbe:
      httpGet:
        path: /
        port: http
  web:
    replicas: 1
  wellKnown:
    enabled: false
  volumes:
    # If left empty, the default storage class will be used
    storageClassName: ""
    # Default accessMode is ReadWriteMany
    accessMode: ""
    # Enable to use PVCs instead of HostPath volumes
    usePVC: false
    upload: 50Gi
    logs: 5Gi
    download: 10Gi
    default: 10Gi
  config:
    yml: "you can set content by --set-file cloud.config.yml=config.yml"
  license:
    pem: "you can set content by --set-file cloud.license.pem=license.pem"
  # Europ/Berlin 5 AM - UTC 3 AM - 0 3 * * *
  # America/NewYork 6 AM - UTC 10 AM - 0 10 * * *
  # America/California 3 AM - UTC 10 AM - 0 10 * * *
  # Asia/Mumbai 5 AM - UTC 11:30 PM - 30 11 * * *
  # Asia/Seoul 5 AM - UTC 20 PM - 0 20 * * *
  cleanUpSchedule: "* 20 * * *"

nginx:
  replicas: 1

db:
  volume: 20Gi
  # If left empty, the default storage class will be used
  storageClassName: ""
  service:
    port: 5432
  env:
    POSTGRES_USER: postgres
    POSTGRES_PASSWORD: ""
    DB_DATABASE: proteam
    DB_DATABASE_ANALYTICS: analytics
    DB_READ_USER: protopie_r
    DB_WRITE_USER: protopie_w
    # If left empty, a random password will be generated automatically
    DB_READ_PASSWORD: ""
    # If left empty, a random password will be generated automatically
    DB_WRITE_PASSWORD: ""
  extra:
    envs: []
  ## @param db.resources Set container requests and limits for different resources like CPU or memory (essential for production workloads)
  ## Example:
  ## resources:
  ##   requests:
  ##     cpu: 2
  ##     memory: 512Mi
  ##   limits:
  ##     cpu: 3
  ##     memory: 1024Mi
  ##
  resources: {}

postgresql:
  enabled: false
  image:
    tag: 14.15.0
  auth:
    username: postgres
    password: postgres
    database: proteam
  service:
    ports:
      postgresql: 5432
  primary:
    nodeSelector: *nodeSelector
    initdb:
      scriptsConfigMap: postgres-init-script-configmap
    # If left empty, the default storage class will be used
    storageClassName: ""
    persistence:
      size: 20G
    persistentVolumeClaimRetentionPolicy:
      enabled: true
